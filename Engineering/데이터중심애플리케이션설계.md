

# 01 

최근에는 데이터 중심의 애플리케이션이 많다.
성능보다는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도 때문에 문제가 생긴다.

서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 애플리케이션 프로그래밍 인터페이스(API)는
보통 클라이언트가 모르게 구현 세부 사항을 숨긴다.

소프트웨어 시스템에서 세 가지를 중시한다.

**신뢰성, 확장성, 유지보수성**

## 신뢰성

많은 중대한 버그는 미흡한 오류처리에 기인한다.
고의적으로 결함을 유도함으로써, 내결함성 시스템을 지속적으로 훈련하고 테스트해서,
실제 결함이 발생했을 때 올바르게 처리할 수 있는 자신감을 높힌다. (넷플릭스 카오스 몽키)



### 하드웨어 결함 

AWS같은 일부 클라우드 플랫폼은 가상 장비 인스턴스가 별도의 경고 없이 죽는 경우가 일반적이다.
이런 플랫폼은 단일 장비 신뢰성보다 유연성과 탄력성을 우선적으로 처리하게끔 설계됐기 때문이다.

따라서, 하드웨어 중복성을 통해 장비의 손실을 견딜 수 있는 시스템으로 옮겨가는 추세다.
무중단 배포가 가능하다.

### 소프트웨어 오류처리에

소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.
상호작용에 대해 깊게 생각하기.
빈틈없는 테스트,
프로세스 격리,
죽은 프로세스의 재시작 허용
모니터링
프로덕션 환경에서 시스템 동작의 측정 등등


### 인적오류

어떻게 하면 인적오류를 줄일까?

추상화를 잘 하면 된다.

테스트 환경,

단위테스트부터 통합테스트까지 철저한 테스트
상세하고 명확한 모니터링 대책


신뢰성은 중요하다. 매출에 손실을 주고 명성에 타격을 준다.


## 확장성

현재 안정적으로 동작해도 미래에도 그럴 거란 보장은 없다.
**시스템이 커지면 이에 대처하기 위한 선택은 무엇인가?**를 고민해야 한다.

### 부하 기술하기

부하 매개변수를 적어라.
(웹 서버의 초당 요청 수, DB 읽기 쓰기 비율, 동시 active user, 캐시 적중률)

### 성능 기술하기

하둡 같은 일괄처리시스템은 처리량(throughput)에 관심을 갖는다.

온라인 시스템은 응답시간을 중시한다.

보고된 서비스 평균 응답시간을 살피는 일이 일반적이다.
평균은 좋은 지표는 아니다.
백분위를 사용하는 편이 좋다.
가장 빠른 응답시간 가장 느린 응답시간의 중간값을 보면 된다.

**꼬리지연시간** 

보통 느린 응답시간을 경험한 유저는
많은 데이터를 갖고 있어서다 ( 가장 소중한 고객 )


**부하 대응 접근 방식**

적절한 사양의 장비 몇 대가 다량의 낮은 사양 가상 장비보다 훨씬 간단하고 저렴하다.

일부 시스템은 탄력적이다. 부하를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다.


분산시스템을 위한 도구와 추상화가 좋아지면서 분산 시스템이 보편적으로 쓰일 가능성이 있다.

스타트업 초기 단계나 검증되지 않은 제품의 경우에 미래를 가정한 부하에 대비해 확장하기보다는
빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요하다.

### 유지보수성

소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다는 사실은 잘 알려져있다.

운용성, 단순성, 발전성을 염두에 두고 개발해야 한다.

**운용성**

좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다.
하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.

운영 중 일부 측면은 자동화 할 수 있고 자동화해야 한다.

좋은 운영성이란 동일하게 반복되는 테스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에
노력을 집중한다는 의미다.

**단순성**

최상의 도구는 추상화다.
좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.
또한 좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다.
이러한 재사용은 비슷한 기능을 여러 번 재구현하는 것보다 더 효율적일 뿐만 아니라고품질 소프트웨어로 이어진다.

고수준 프로구래밍 언어는 기계언어 CPU 레지스터 시스템 호출을 숨긴 추상화다.
고수준 언어로 프로그래밍해도 여전히 기계어를 사용한다. 단지 직접 사용하지 않을 뿐이다.
프로그래밍 언어의 추상화 덕분에 기계어를 생각할 필요가 없기 때문이다.

**발전성 :변화를 쉽게 만들기**



# 02 데이터 모델과 질의 언어

```
----생각----
2022-10-15
이번 장에서는 데이터 모델이 어떻게 사용되는지 알려준다.
비즈니스 성질에 따라 데이터 모델을 정해야 하며, 각 비즈니스마다 효율적인 방법이 있음을
사례를 통해 왜 중요한지에 대해 설명해준다.
한 상황에서 SQL, NOSQL, 그래프모델을 사용했을 때
어떤 코드가 나오는지 보여줌으로써 왜 효율적인지를 보여준다.

내가 얻어가야 할 것은, 각 데이터 모델이 어떤 상황에 쓰이면 좋을지를 알아가는 것.
--------

```


데이터 모델은 아마도 소프트웨어 개발에서 제일 중요한 부분일 것이다.
왜냐하면 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 **해결하려는 문제를 어떻게 생각**해야 하는지에
대해서도 지대한 영향을 미치기 떄문이다.

## 관계형 모델과 문서 모델

## 객체 관계형 불일치

프로필에서  (유저 정보, 산업 정보, 학력 정보, 지역 정보 )
를 갖는다고 해보자.

관계형일 때는 각 유저테이블, 산업테이블, 학력 테이블을 만들어야 하지만,
문서형은 하나의 문서에 모두 넣어버리면 된다.

### 다대일과 다대다 관계

중복된 데이터를 정규화하려면 다대일 관계가 필요한데 안타깝게도 다대일 관계는 문서 모델에 적합하지 않다. 
문서 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 대한 지원이 보통 약하다.

데이터베이스 자체가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어서 어플리케이션 코드에서 흉내를 내야 한다. 

## 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?

애플리케이션에서 데이터가 문서와 비슷한 구조(일대다 관계 트리로 보통 한 번에 전체 트리를 적재)라면
문서 모델을 사용하는 것이 좋다. 

문서와 비슷한 구조를 여러 테이블로 나누어 찢는 관계형 기법은 다루기 힘든 스키마와 불필요한 
복잡한 애플리케이션 코드를 발생시킨다.

**다대다 관계를 사용한다면, 문서 모델이 좋지 않다.**

문서모델은 스키마로부터 자유롭다.
예시)

만약 name: 박세훈 데이터가 있다

firstName:박 secondName:세훈

이런식으로 나누고 싶다.

문서 모델에서는

```javascript

	if (user && user.name && !user.first_name) {
		user.first_name = user.name[0]
	}

```

데이터베이스에서는

```SQL
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = substring_index(name, ' ', 1);
```

